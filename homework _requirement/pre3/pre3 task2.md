## 面向对象设计与构造预习作业3-2

### 第一部分：训练目标

本次作业考察通过简单的正则表达式对字符串信息进行处理

----

### 第二部分：背景介绍

小明发现在此聊天软件的群聊功能中，如果不是发给某个特定的人的消息，**群聊**消息中不会注明消息的接收者。

因为很多用户希望在**群聊**中让某位用户特别注意到某消息，所以他们喜欢在群聊中发送@某人的信息，这些信息会被系统识别为群聊中发送给相应用户的消息，会提醒被所@的人注意到。

----

### 第三部分：题目描述

形式化来说，消息可能被表现成以下三种模式：

- 给个人的消息：

  ``` 
  2021/07/12-student@teacher :"can i pass the exam?";
  ```

  本消息为发送给个人的消息，指定了接收者teacher。
  
- 群聊中的消息，指定了接收者：

  ``` 
  2021/07/12-student:"can i pass the exam?@teacher ";
  ```
  
  本消息为在群聊中发送的消息，指定了接收者teacher。

- 群聊中的消息，未指定接收者：

  ``` 
  2021/07/12-student:"can i pass the exam?";
  ```
  
  本消息为在群聊中发送的消息，未指定接收者。


输入是具有上述模式的聊天消息，并以指定的形式输入多条询问。

请编写程序，根据输入的查询输出指定发送者、接收者、日期的消息。

----

### 第四部分：输入/输出格式


#### 输入格式

前若干行为消息内容，以一行END_OF_MESSAGE结尾。

其后为多条询问，所有可能出现的询问格式如下：

- `qdate year/month/day` : 查询某日期的消息
- `qsend username` : 查询某用户名发送的消息
- `qrecv username` : 查询某用户名接收的消息。请注意，**所有“群聊中@某用户的消息”均算作该用户接收的消息，即接受的消息包括：私聊该用户的消息和群聊中@某用户的消息**。

#### 输出格式

对于每一条询问，输出指定消息（输入数据中可能存在多条消息符合条件，此时按照**原顺序、原格式**输出全部符合条件的消息）。

输出中每条消息均单独占据一行。

#### 输入样例

```
2021/7/1-Jack@JayChou :"Hello!";2021/7/3-JayChou@buaaer :"Hahaha";
2021/7/5-JayChou@Mike :"emmmm";         2021/7/8-JayChou@buaaer :"Hahaha";
2021/7/8-JayChou:"Hahaha"; 2021/5/3-Mike:"he@buaaer is unhappy";
END_OF_MESSAGE
qdate 2021/7/1
qsend JayChou
qrecv buaaer
```

#### 输出样例

```
2021/7/1-Jack@JayChou :"Hello!";
2021/7/3-JayChou@buaaer :"Hahaha";
2021/7/5-JayChou@Mike :"emmmm";
2021/7/8-JayChou@buaaer :"Hahaha";
2021/7/8-JayChou:"Hahaha";
2021/7/3-JayChou@buaaer :"Hahaha";
2021/7/8-JayChou@buaaer :"Hahaha";
2021/5/3-Mike:"he@buaaer is unhappy";
```

####  数据限制

- 日期仅以 **year/month/day** 形式给出，$year \isin [0, 9999], mounth \isin [1, 12], day \isin [0,31]$。日期中可能存在前导`0`，比如`1`月可以表示为`01`月，`258`年可以表示为`0258`年。
- 发送者和接收者的用户名仅由**大小写英文字母、数字**组成。
- 正文内容仅由**大小写英文字母、数字、空格、四种标点符号（? ! , .）构成**。
- 输入数据中所有内容均对大小写**敏感**。
- 如果一条消息中存在@用户的情况（对应前两种消息模式），则保证该信息中`@+用户名`结构后面一定**有一个空格**，而且@用户最多只会在一个消息中出现一次。
- 日期、用户名、正文都非空。

- 不超过300行
- 每行不超过10个消息
- 总询问数不超过100条

----

### 第五部分：提示与说明

- 正则表达式是一种强力的字符串结构化处理工具。正则表达式具有以字符串的形式描述一个字符串集合的能力，被频繁地用在字符串匹配等任务中。
  - 正则表达式预定义了很多字符集合：如`\d`代表所有数字字符，`\s`代表所有空白字符，`\w`代表字母、数字或下划线字符。
  - 正则表达式具有灵活的特性。`*`符号与`+`符号提供了不定次数重复功能，`{}`则可以重复指定次数；`[]`提供了构造自己的字符集合的方法，而`()`则可以将字符串进行划分。
- Java语言对正则表达式提供了多方面的支持。
- 你可以使用字符串的matches方法来检验字符串是否属于正则表达式所表示的集合；split函数中的分割符也可以填入正则表达式；
- 此外Java中还有**Pattern类**专门用来表示正则表达式。你可以使用Pattern.complie()方法将字符串转换为正则表达式。
- 由Pattern类的matcher方法构造的**Matcher类**则提供了多种多样的使用正则表达式对字符串进行匹配的方法：
  - 使用find方法可以实现在同一个字符串中使用正则表达式连续的进行匹配；
  
  - 使用group方法则可以从匹配中提取出与部分正则表达式相对应的子串；
  
  - 使用start、end方法则可以获取匹配在目标字符串中的位置信息；
  
  - 使用region方法还可以限定正则表达式进行匹配的范围；
  
    下面同样以一个例子来简单介绍正则表达式的使用：

我们知道，java语言中存在着“包”这一概念。使用package关键字可以轻松的将java程序划分为不同的包，并建立起一套层次结构。

一般来说，包会使用倒置的域名作为其名字，如`com.oocourse.spec1.io`, `org.apache.catalina`, `com.xiaoming.log`等；

给定一个带有package关键字的java文件的内容(保证包名仅大由小写字母、数字、下划线构成)，请你输出该java文件所在的包以及该包的二级域名。

首先，写出package语句所对应的正则表达式如下：

`^package \w+(\.\w+)+;`

其中+表示至少匹配1次;^表示匹配行首。

得到了对应的表达式，我们就可以对字符串进行匹配。具体的程序如下：
```java
    public static final String PACKAEG_PATTERN = "^package \\w+(\\.\\w+)+";

    public static String getSecondDomain(String javaFileContent) {
        Pattern pattern = Pattern.compile(PACKAEG_PATTERN);         //将定义好的正则表达式字符串转换为正则表达式对象
        Matcher matcher = pattern.matcher(javaFileContent);         //将正则表达式结合到输入数据上
        if (!matcher.find()) {                                      //尝试进行匹配
            throw new RuntimeException("Invalid input!");           //失配，报错
        }
        String[] urlParts = matcher.group()                         //匹配成功，获得匹配到的字符串
                            .split("\\.");                          //对匹配进行切分。注意split方法的参数也是正则表达式
        if (urlParts.length < 2) {
            System.err.println("package name's too simple!");
        }
        return urlParts[1];
    }
```
值得注意的是，为了简化处理流程，该程序中的正则表达式并没有使用分号；但是由于正则表达式默认的**非贪婪匹配**特性，不会出现包名没有完全匹配到的结果。

此外，本任务也可以使用功能更强大的*捕获组*来完成。