# 第一单元训练指导书

## 训练目的

- 讲解并练习几种解析表达式的方式，为正式作业中自行解析表达式提供几个可行的思路。
- 通过训练的代码，引导第一单元的架构设计。

## 教程

对于输入的字符串，我们需要将其解析成一个结构化的对象，以方便后续进行操作。在大一的《数据结构》课程中，大家已经学过如何使用“栈”来解析表达式并将其转化为后缀式处理。虽然栈解析的方式可以很好地处理括号，但是表达式本身是一种**层次化**的结构，栈解析的方法无法体现出表达式的层次结构，也不利于表达式的变形和化简，因此我们**不鼓励**在作业中使用这种方法。

下面介绍一些层次化解析表达式的方法。

### 表达式的层次化结构

考虑一个只含有**加减**和**乘除**的表达式，受到形式化表述的启发，我们可以把表达式划分为三层：

- 最底层是表达式的基本元素（例如数字）称为因子
- 中间是由乘除法连接的数字，称为项
- 最上层是由加减法连接的项，称为表达式

不难发现，**层次化定义和表达式的运算优先级是一一对应的**。通过层次化定义，我们规定了表达式的层次结构，而层次结构中也隐含了表达式的运算顺序：在处理高层次的结构之前，必须先处理低层次结构的子对象。

### 正则表达式法

我们已经为表达式划分好了层次，下面可以考虑利用**正则表达式**来解析这些对象。

对于每个层次的对象，我们可以考虑用正则表达式对其进行描述。假设当前子串能匹配上某个部分的正则表达式，说明这个子串可以调用这个层次对应的方法进行解析。对于每个部分我们都会有一个方法来解析，因此可以考虑使用**工厂模式**进行建模。

例如项的形式为 `数字 +/- 数字 +/- ...`，我们可以编写出对应的正则表达式和对应的解析方法，然后尝试用正则表达式去匹配当前的子串。如果匹配上了，则调用对应的方法解析；否则，尝试另外的匹配模式。

### 嵌套括号的处理

上面介绍的正则表达式法可以处理普通的因子、项等结构。但是当表达式结构更复杂，尤其是出现嵌套表达式，即带括号的表达式或调用函数的表达式时，就无法使用正则表达式进行解析了（具体原因将会在下学期的课程中学到）。对于这种情况，我们可以采用递归解析的方式进行处理。

假设我们解析表达式的方法为 `Expr parseExpr(String)`，它会传入一个 `String` 对象并返回构造好的表达式。那么当解析到括号时，我们可以先找到与这个括号匹配的对应括号，然后对这个左右括号间的子串递归调用 `parseExpr` 方法进行解析。

例如解析复杂表达式 `2 * (3 + 4 * (5 + 6)) + 1`，首先对整个字符串调用 `parseExpr` 方法进行解析。在解析第一个项时，我们会遇到第一个括号。此时找到匹配的括号并提取出括号中的子串 `3 + 4 * (5 + 6)`，然后对这个子串递归调用方法解析，将解析返回的对象 `Expr` 看作一个因子，然后按照项的方法进行处理。

## 训练任务

### 一、简单表达式解析

#### 任务说明简洁版

本部分中，我们需要大家补全一个程序（官方提供），能够读入一个不带括号、运算符只有 `+` 和 `*` 的表达式，然后输出其后缀表达形式。

例如，我们的输入：

```
1+2*3+2
```

我们需要大家输出：

```
1 2 3 * + 2 +
```

#### 任务说明完整版

本部分中，我们需要大家补全一个程序（官方提供，在 `basic` 目录下），能够读入一个不带括号、运算符只有 `+` 和 `*` 的表达式，然后输出其后缀表达形式。

##### 表达式的形式化描述

在本次训练中，输入的表达式的形式我们仍然采用形式化定义的方式：

- 表达式 $\rightarrow$ 表达式 + 项 | 项
- 项 $\rightarrow$ 项 $*$ 因子 | 因子
- 因子 $\rightarrow$ 数字因子
- 数字因子 $\rightarrow$ (1|2|3|4|5|6|7|8|9){0|1|2|3|4|5|6|7|8|9}

其中，上面的形式化描述的含义如下：

| 符号            | 名称        | 含义                       | 样例           | 样例解释                                                                                                                           |
| ------------- | --------- | ------------------------ | ------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| $\rightarrow$ | 生成符       | 由前置表达式可以生成后置表达式          | A->Ba        | 由前置表达式 `A` 可以生成表达式 `B` 后接小写字母 `a` 的表达式                                                                                         |
| \|            | ‘或’选择符    | 从由‘或’选择符连接的集合中选择一个       | A->a\|b      | 由前置表达式 `A` 可以生成 小写字母 `a` 或 小写字母 `b`                                                                                            |
| [ ]           | ‘0或1’ 选择符 | 可以从中括号内的表达式中选择0个或1个表达式   | A->[B]a      | 由前置表达式 `A` 可以生成 `Ba` 或 `a`                                                                                                     |
| { }           | ‘0或多’ 选择符 | 可以从花括号内的表达式中选择0个或1个多个表达式 | A->{a\|b\|c} | 由前置表达式 `A` 可以生成由小写字母 `a、b、c` 组成的可以为空的字符串   如: $\emptyset$ (空串), `a`, `b`, `c`, `aa`, `ab`, `bc`, `ca`, `acb`, `acbccaabcba` 等等 |

##### 输入

一行，是一个符合形式化描述的表达式。

##### 输出

上述表达式转化成后缀表达式的形式。

##### 样例输入

```
1+2*3+2
```

##### 样例输出

```
1 2 3 * + 2 +
```

### 二、递归表达式解析

#### 任务说明简洁版

本部分中，我们需要大家补全一个程序（官方提供，在 `advance` 目录下），能够读入一个带有括号、运算符只有 `+` 和 `*` 的表达式，然后输出其后缀表达形式。

例如，我们的输入：

```
(1+2)*(3+4)
```

我们需要大家输出：

```
1 2 + 3 4 + *
```

#### 任务说明完整版

本部分中，我们需要大家补全一个程序（官方提供），能够读入一个**带括号**、运算符只有 `+` 和 `*` 的表达式，然后输出其后缀表达形式。

##### 表达式的形式化描述

在本次训练中，输入的表达式的形式我们仍然采用形式化定义的方式：

- 表达式 $\rightarrow$ 表达式 + 项 | 项
- 项 $\rightarrow$ 项 $*$ 因子 | 因子
- 因子 $\rightarrow$ 数字因子 | 表达式因子
- 数字因子 $\rightarrow$ (1|2|3|4|5|6|7|8|9){0|1|2|3|4|5|6|7|8|9}
- 表达式因子 $\rightarrow$ '(' 表达式 ')'

##### 输入

一行，是一个符合形式化描述的表达式。

##### 输出

上述表达式转化成后缀表达式的形式。

##### 样例输入

```
(1+2)*(3+4)
```

##### 样例输出

```
1 2 + 3 4 + *
```

## 扩展：另一种解析方法

**这一部分不是必须掌握的内容**，上面介绍的正则表达式法已经足够处理表达式的解析，因此仅留给感兴趣的同学进行扩展学习。

通过利用形式化表述定义，我们已经将表达式分成了三个层次：因子（数字）、项（乘除）、表达式（加减），这三种结构对应了三种对象。我们下面分别进行讨论对这些对象的解析：

- 对于因子（数字）的解析非常简单：只要不断看下一个字符是否是数字即可。如果不是数字，那么说明下一个符号不属于因子，即对因子的解析结束。
- 下面考虑怎么解析“项”。项由因子和乘除符号组成，因此解析项分为下面几个部分：
  + 项的开头一定是一个因子，因此我们可以直接调用因子的解析方法，将任务交给“因子”类
  + 因子后面跟着的字符有两种可能：乘除或其他符号
    + 如果下一个字符是乘除符号，那么读入这个符号并做处理。此时跟在乘除号后面的一定还是一个项，回到第一步
    + 否则，说明这个项的解析已经结束了，后面的字符不再是这个项的内容（不可能是数字，否则会在前面一步解析），退出并返回构造好的项即可
- 最后考虑如何解析表达式。表达式由项和加减符号组成，可以模仿上面对“项”的解析方法对步骤进行拆分：
  + 表达式的开头可以直接调用项的解析方法
  + 解析完一个项，同样有两种可能：如果下一个字符是加减符号，那么读入这个符号并做处理，然后下一个符号一定是一个项；否则，说明表达式的解析结束了

上面所举例子中的表达式结构比较简单，但是即使结构变得更加复杂（比如增加乘方或括号等），依旧可以通过形式化表述来建立层次，并且通过方法的互相调用完成解析。这种方法的好处在于，它可以通过方法之间的间接递归调用，非常自然地处理嵌套的表达式（即带嵌套括号的表达式）。熟悉编译原理的同学可能会发现，这就是编译中的**递归下降算法**。

## 提交方式

请提交补全后的代码至第一单元个人训练仓库（两个题目放在同一仓库即可，其中第一题放在 `basic` 目录下，第二题放在 `advance` 目录下）。如图：

```
basic
| -- expression
| -- | -- Term.java
| -- | -- Expr.java
| -- MainClass.java
advance
| -- expr
| -- | -- Term.java
| -- | -- Expr.java
| -- | -- Factor.java
| -- | -- Number.java
| -- Lexer.java
| -- Parser.java
| -- MainClass.java
```
